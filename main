local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local RS = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")

setthreadidentity(5)
local ClientAnimalReady = RS:WaitForChild("ClientAnimalReady")
local oldFire; oldFire = hookfunction(ClientAnimalReady.FireServer, function(...)
    if not checkcaller() and select(1, ...) == ClientAnimalReady then return nil end
    return oldFire(...)
end)

local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local Root = Character:WaitForChild("HumanoidRootPart")

Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)

local Packets = require(RS.Modules.Packets)
local GameUtil = require(RS.Modules.GameUtil)
local ItemIDS = require(RS.Modules.ItemIDS)
local ItemData = require(RS.Modules.ItemData)

Player.CharacterAdded:Connect(function(char)
    Character = char
    Humanoid = char:WaitForChild("Humanoid")
    Root = char:WaitForChild("HumanoidRootPart")
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)
end)

local config = {waitTime = 0.01, positions = {}}
local config2 = {waitTime = 0.01, positions = {}}

task.spawn(function()
    local success, result = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Zacharificy/goldfarm/main/tweens"))()
    end)
    if success and result then config = result end
end)

task.spawn(function()
    local success, result = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Zacharificy/goldfarm/main/tweens2"))()
    end)
    if success and result then config2 = result end
end)

local S = {
    autoHit = false,
    noclip = false,
    autoEat = false,
    tween = false,
    pickupGold = false,
    pickupCoal = false,
    pickupCoins = false,
    coinPress = false,
    campfireFuel = false,
    tpRawGoldToChest = false,
    pickupGoldFromChest = false,
    blackScreen = false,
    fruit = "Lemon",
    hitRadius = 200,
    waitTime = 0.01,
    positionList = {},
    tweenSpeed = 16,
    isMoving = false,
    lastEatTime = 0,
    chest = nil,
    CampfireTracker = {},
    autoRetoolEnabled = false,
    retoolChoice = "God Pick",
    retoolThread = nil,
    hideItems = false,
    hiddenItems = {},
    selectedPath = "Path 1"
}

local HUNGER_CAP = 100
local EAT_AT = 90
local EAT_COOLDOWN = 1.5

local CFG = {
    GOLD_ID = 597,
    CRYSTAL_ID = 436,
    GOD_AXE_ID = 454,
    GOD_PICK_ID = 132,
    NEED_GOLD = 12,
    NEED_CRYSTAL = 3
}

local Connections = {}
local Tasks = {}
local Cache = {
    Items = workspace:FindFirstChild("Items"),
    Resources = workspace:FindFirstChild("Resources"),
    Deployables = workspace:FindFirstChild("Deployables")
}

local fruitOptions = {}
task.spawn(function()
    for name, data in pairs(ItemData) do
        if data.grows then table.insert(fruitOptions, name) end
    end
    table.sort(fruitOptions)
end)

local function chosenName() 
    return (S.retoolChoice == "God Axe") and "God Axe" or "God Pick" 
end

local function chosenCraftID() 
    return (S.retoolChoice == "God Axe") and CFG.GOD_AXE_ID or CFG.GOD_PICK_ID 
end

local function getToolbar() 
    return (GameUtil and GameUtil.Data and GameUtil.Data.toolbar) or {} 
end

local function getEquipped() 
    return GameUtil and GameUtil.Data and GameUtil.Data.equipped 
end

local function toolbarFindChosenSlot()
    for slot, entry in pairs(getToolbar()) do
        local name = entry and (entry.name or (entry.itemID and idToName(entry.itemID)))
        if name == chosenName() then return slot end
    end
    return nil
end

local function equippedIsChosen()
    local eq = getEquipped()
    if type(eq) == "number" then
        local e = getToolbar()[eq]
        local nm = e and (e.name or (e.itemID and idToName(e.itemID)))
        return nm == chosenName()
    elseif type(eq) == "string" then
        return eq == chosenName()
    elseif type(eq) == "table" then
        local nm = eq.name or (eq.itemID and idToName(eq.itemID))
        return nm == chosenName()
    end
    return false
end

local function ensureMaterials()
    local g = tonumber((getQuantity("Gold"))) or 0
    local c = tonumber((getQuantity("Crystal Chunk"))) or 0

    local needGold = math.max(0, CFG.NEED_GOLD - g)
    local needCrystal = math.max(0, CFG.NEED_CRYSTAL - c)

    for i = 1, needGold do
        Packets.PurchaseFromShop.send(CFG.GOLD_ID)
        task.wait()
    end

    for i = 1, needCrystal do
        Packets.PurchaseFromShop.send(CFG.CRYSTAL_ID)
        task.wait()
    end
end

local function craftAndEquipFromHotbar()
    ensureMaterials()

    Packets.CraftItem.send(chosenCraftID())
    task.wait(0.5)

    local t0 = os.clock()
    local slot
    repeat
        slot = toolbarFindChosenSlot()
        if slot then break end
        task.wait(0.1)
    until os.clock() - t0 > 3

    if not slot then
        task.wait(0.3)
        slot = toolbarFindChosenSlot()
    end

    if slot then
        Packets.EquipTool.send(slot)
        return true
    else
        Library:Notify('Crafted, but tool not found in hotbar.')
        return false
    end
end

local function autoRetoolLoop()
    while S.autoRetoolEnabled do
        if not equippedIsChosen() then
            local slot = toolbarFindChosenSlot()
            if slot then
                Packets.EquipTool.send(slot)
            else
                craftAndEquipFromHotbar()
            end
        end
        task.wait(0.5)
    end
end

local function hideItemsOnFloor()
    if not Cache.Items then return end
    
    for _, item in ipairs(Cache.Items:GetChildren()) do
        if not S.hiddenItems[item] then
            S.hiddenItems[item] = true
            for _, part in ipairs(item:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.Transparency = 1
                    part.CanCollide = false
                elseif part:IsA("Decal") or part:IsA("Texture") then
                    part.Transparency = 1
                end
            end
        end
    end
end

local function showItemsOnFloor()
    if not Cache.Items then return end
    
    for item in pairs(S.hiddenItems) do
        if item and item.Parent then
            for _, part in ipairs(item:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.Transparency = 0
                    part.CanCollide = true
                elseif part:IsA("Decal") or part:IsA("Texture") then
                    part.Transparency = 0
                end
            end
        end
    end
    table.clear(S.hiddenItems)
end

local function setupAntiAFK()
    local GC = getconnections or get_signal_cons
    if GC then
        for _, v in pairs(GC(Player.Idled)) do
            if v.Disable then v:Disable() elseif v.Disconnect then v:Disconnect() end
        end
    else
        local VirtualUser = game:GetService("VirtualUser")
        Player.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end
end

local hitDebounce = false
local function hitResources()
    if hitDebounce or not Root.Parent then return end
    hitDebounce = true
    
    local entities = {}
    local rootPos = Root.Position
    local radiusSq = S.hitRadius * S.hitRadius
    
    if Cache.Resources then
        for _, res in ipairs(Cache.Resources:GetChildren()) do
            if res.Parent then
                local ok, pivot = pcall(res.GetPivot, res)
                if ok then
                    local dist = (rootPos - pivot.Position).Magnitude
                    if dist * dist <= radiusSq then
                        local id = res:GetAttribute("EntityID")
                        if id then entities[#entities + 1] = id end
                    end
                end
            end
        end
    end
    
    if #entities > 0 then pcall(Packets.SwingTool.send, entities) end
    task.delay(0.06, function() hitDebounce = false end)
end

local function noclip()
    if Cache.Deployables then
        for _, v in ipairs(Cache.Deployables:GetChildren()) do
            local door = v:FindFirstChild("Door")
            if door then
                door.Transparency = S.noclip and 0.5 or 0
                door.CanCollide = not S.noclip
            end
        end
    end
    
    if S.noclip and Character then
        for _, part in ipairs(Character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = false
            end
        end
    end
end

local function findFruit(name)
    for idx, data in next, GameUtil.getData().inventory do
        if data.name == name then return idx end
    end
end

local function getHunger()
    local stats = GameUtil and GameUtil.Data and GameUtil.Data.stats
    return stats and stats.food
end

local function autoEat()
    while S.autoEat do
        local hunger = getHunger()
        if S.fruit and hunger and hunger <= EAT_AT and (tick() - S.lastEatTime) >= EAT_COOLDOWN then
            local idx = findFruit(S.fruit)
            if idx then
                Packets.UseBagItem.send(idx)
                S.lastEatTime = tick()
            end
        end
        task.wait(0.8)
    end
end

local function createPickup(itemName, checkChests, stateKey)
    return function()
        local cache = {}
        while S[stateKey] do
            if Cache.Items then
                for _, item in ipairs(Cache.Items:GetChildren()) do
                    if item.Name == itemName and not cache[item] then
                        local id = item:GetAttribute("EntityID")
                        if id then
                            cache[item] = true
                            for i = 1, 10 do Packets.Pickup.send(id) end
                            task.delay(0.3, function() cache[item] = nil end)
                        end
                    end
                end
            end
            
            if checkChests and Cache.Deployables then
                for _, chest in ipairs(Cache.Deployables:GetChildren()) do
                    local contents = chest:FindFirstChild("Contents")
                    if contents then
                        for _, item in ipairs(contents:GetChildren()) do
                            if item.Name == itemName and not cache[item] then
                                local id = item:GetAttribute("EntityID")
                                if id then
                                    cache[item] = true
                                    for i = 1, 10 do Packets.Pickup.send(id) end
                                    task.delay(0.3, function() cache[item] = nil end)
                                end
                            end
                        end
                    end
                end
            end
            RunService.Heartbeat:Wait()
        end
    end
end

local pickupGolds = createPickup("Raw Gold", false, "pickupGold")
local pickupCoals = createPickup("Coal", false, "pickupCoal")
local pickupCoins = createPickup("Coin", false, "pickupCoins")

local function getDeployable(name, range)
    if not Cache.Deployables or not Root then return nil end
    
    local closest, closestDist = nil, range or math.huge
    local rootPos = Root.Position
    
    for _, v in ipairs(Cache.Deployables:GetChildren()) do
        if v.Name == name and v:IsA("Model") then
            local ok, pivot = pcall(v.GetPivot, v)
            if ok then
                local dist = (rootPos - pivot.Position).Magnitude
                if dist < closestDist then
                    closest, closestDist = v, dist
                end
            end
        end
    end
    return closest
end

local function GetDeployable(name, range, multiple)
    local deployablesFolder = Cache.Deployables
    if not deployablesFolder or not Root then
        return multiple and {} or nil
    end

    range = tonumber(range) or math.huge

    if multiple then
        local results = {}
        for _, v in ipairs(deployablesFolder:GetChildren()) do
            if v.Name == name and v:IsA("Model") then
                local ok, pivot = pcall(function() return v:GetPivot() end)
                if ok and pivot then
                    local dist = (Root.Position - pivot.Position).Magnitude
                    if dist < range then
                        table.insert(results, { deployable = v, range = dist })
                    end
                end
            end
        end
        table.sort(results, function(a, b) return a.range < b.range end)
        return results
    else
        return getDeployable(name, range)
    end
end

local function getQuantity(name)
    for _, v in next, GameUtil.getData().inventory do
        if v.name == name then return v.quantity end
    end
    return 0
end

local SEND_DT = 0.01
local LOOKUP_DT = 2
local BURST_MAX = 10

local function pressCoins()
    local press, entityID, lastLookup, lastSend = nil, nil, 0, 0

    while S.coinPress do
        local now = os.clock()

        if (not press or not press.Parent or (now - lastLookup) >= LOOKUP_DT) then
            press = getDeployable("Coin Press", 25)
            entityID = (press and press:GetAttribute("EntityID")) or nil
            lastLookup = now
        end

        if entityID then
            local goldAmt = getQuantity("Gold") or 0
            if goldAmt > 0 and (now - lastSend) >= SEND_DT then
                local n = math.min(goldAmt, BURST_MAX)
                for i = 1, n do
                    Packets.InteractStructure.send({ entityID = entityID, itemID = ItemIDS.Gold })
                end
                lastSend = now
            end
        end

        RunService.Heartbeat:Wait()
    end
end

local function getCampfireCapacity(campfireName)
    local data = ItemData[campfireName]
    return data and data.capacity or 100
end

local function getFuelBurnValue(fuelName)
    local data = ItemData[fuelName]
    return data and data.fuelValue or 60
end

local function shouldRefuelCampfire(campfire, currentTime)
    local tracked = S.CampfireTracker[campfire]
    if not tracked then
        return true
    end
    
    local elapsed = currentTime - tracked.lastFuelTime
    local remaining = math.max(0, tracked.fuelAmount - elapsed)
    
    return remaining <= 10
end

local function trackCampfireFuel(campfire, fuelName)
    local currentTime = tick()
    local fuelValue = getFuelBurnValue(fuelName)
    local capacity = getCampfireCapacity(campfire.Name)
    
    if not S.CampfireTracker[campfire] then
        S.CampfireTracker[campfire] = {
            lastFuelTime = currentTime,
            fuelAmount = fuelValue
        }
    else
        local tracked = S.CampfireTracker[campfire]
        local elapsed = currentTime - tracked.lastFuelTime
        local currentFuel = math.max(0, tracked.fuelAmount - elapsed)
        
        tracked.fuelAmount = math.min(currentFuel + fuelValue, capacity)
        tracked.lastFuelTime = currentTime
    end
end

local function idToName(id)
    for name, data in pairs(ItemData) do
        if type(data) == "table" and (data.id == id or data.itemID == id) then return name end
    end
    for name, _id in pairs(ItemIDS) do
        if _id == id then return name end
    end
    return nil
end

local function GetFuel()
    for x, v in next, GameUtil.getData().inventory do
        if ItemData[v.name] and ItemData[v.name]["fuels"] then
            return ItemIDS[v.name]
        end
    end
    return nil
end

local function campfireRefuel()
    local CHECK_INTERVAL = 1
    local REFUEL_THRESHOLD = 10
    
    while S.campfireFuel do
        task.wait(CHECK_INTERVAL)
        
        local currentTime = tick()
        local campfires = GetDeployable("Campfire", 40, true) or {}
        
        for trackedCampfire in pairs(S.CampfireTracker) do
            if not trackedCampfire.Parent then
                S.CampfireTracker[trackedCampfire] = nil
            end
        end
        
        for _, rec in ipairs(campfires) do
            local campfire = rec.deployable
            
            local tracked = S.CampfireTracker[campfire]
            local remainingFuel = 0
            
            if tracked then
                local elapsed = currentTime - tracked.lastFuelTime
                remainingFuel = math.max(0, tracked.fuelAmount - elapsed)
            end
            
            if remainingFuel <= REFUEL_THRESHOLD then
                local fuel = GetFuel()
                if fuel then
                    local entityID = campfire:GetAttribute("EntityID")
                    if entityID then
                        local fuelName = idToName(fuel)
                        if not fuelName then continue end
                        
                        local fuelValue = getFuelBurnValue(fuelName)
                        
                        for i = 1, 2 do
                            Packets.InteractStructure.send({
                                entityID = entityID,
                                itemID = fuel
                            })
                            task.wait(0.05)
                        end
                        
                        S.CampfireTracker[campfire] = {
                            lastFuelTime = currentTime,
                            fuelAmount = fuelValue * 2
                        }
                        
                        task.wait(0.2)
                    end
                end
            end
        end
    end
    
    table.clear(S.CampfireTracker)
end

local function tpRawGold()
    while S.tpRawGoldToChest do
        if not S.chest or not S.chest.Parent then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then task.wait(0.3) continue end
        end
        
        local inventory = GameUtil.getData().inventory
        for idx, data in pairs(inventory) do
            if data.name == "Raw Gold" and data.quantity > 0 then
                local dropAmount = math.min(data.quantity, 100)
                for i = 1, dropAmount do
                    Packets.DropBagItem.send(idx, 1)
                end
                
                task.wait(0.02)
                
                if Cache.Items then
                    for _, item in ipairs(Cache.Items:GetChildren()) do
                        if item.Name == "Raw Gold" then
                            local id = item:GetAttribute("EntityID")
                            if id and S.chest and S.chest.Parent then
                                Packets.ForceInteract.send(id)
                                pcall(item.PivotTo, item, S.chest:GetPivot() * CFrame.new(0, 2, 0))
                                Packets.ForceInteract.send()
                            end
                        end
                    end
                end
                break
            end
        end
        RunService.Heartbeat:Wait()
    end
end

local function pickupGoldFromChest()
    while S.pickupGoldFromChest do
        if not S.chest or not S.chest.Parent then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then task.wait(0.5) continue end
        end
        
        local contents = S.chest:FindFirstChild("Contents")
        if contents then
            for _, item in ipairs(contents:GetChildren()) do
                if item.Name == "Gold" then
                    local id = item:GetAttribute("EntityID")
                    if id then
                        for i = 1, 10 do Packets.Pickup.send(id) end
                    end
                end
            end
        end
        RunService.Heartbeat:Wait()
    end
end

local blackScreenGui = nil
local originalLighting = {}

local function enableBlackScreen()
    if not blackScreenGui then
        blackScreenGui = Instance.new("ScreenGui")
        blackScreenGui.Name = "BlackScreenOptimizer"
        blackScreenGui.IgnoreGuiInset = true
        blackScreenGui.ResetOnSpawn = false
        
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundColor3 = Color3.new(0, 0, 0)
        frame.BorderSizePixel = 0
        frame.Parent = blackScreenGui
        
        blackScreenGui.Parent = Player:WaitForChild("PlayerGui")
    end
    
    originalLighting = {
        Brightness = Lighting.Brightness,
        GlobalShadows = Lighting.GlobalShadows,
        OutdoorAmbient = Lighting.OutdoorAmbient,
        Ambient = Lighting.Ambient,
    }
    
    Lighting.Brightness = 0
    Lighting.GlobalShadows = false
    Lighting.OutdoorAmbient = Color3.new(0, 0, 0)
    Lighting.Ambient = Color3.new(0, 0, 0)
    
    for _, effect in pairs(Lighting:GetChildren()) do
        if effect:IsA("PostEffect") then effect.Enabled = false end
    end
end

local function disableBlackScreen()
    if blackScreenGui then
        blackScreenGui:Destroy()
        blackScreenGui = nil
    end
    
    if originalLighting.Brightness then
        Lighting.Brightness = originalLighting.Brightness
        Lighting.GlobalShadows = originalLighting.GlobalShadows
        Lighting.OutdoorAmbient = originalLighting.OutdoorAmbient
        Lighting.Ambient = originalLighting.Ambient
    end
    
    for _, effect in pairs(Lighting:GetChildren()) do
        if effect:IsA("PostEffect") then effect.Enabled = true end
    end
end

local tween = nil
local tweenConn = nil

local function startTweening()
    if #S.positionList == 0 then
        Library:Notify('No positions available')
        return
    end

    local REACH_RADIUS = 5
    local MIN_IMPROVE_STUDS = 0.5
    local NO_PROGRESS_SECS = 3
    local TELEPORT_BACK_DINC = 12
    local TELEPORT_STEP_JUMP = 20
    local RUBBER_DEV_STUDS = 8
    local SETTLE_SECS = 0.5
    local MAX_RB_PER_NODE = 4
    local JUMP_SAMPLE_SECS = 0.15

    local function nearestIndex(fromPos)
        local bestI, bestD = 1, math.huge
        for j = 1, #S.positionList do
            local p = S.positionList[j]
            if p and p.X and p.Y and p.Z then
                local d = (fromPos - Vector3.new(p.X, p.Y, p.Z)).Magnitude
                if d < bestD then bestI, bestD = j, d end
            end
        end
        return bestI
    end

    local curIndex = nearestIndex(Root.Position)
    local fails = table.create(#S.positionList, 0)
    local rbCount = table.create(#S.positionList, 0)

    while S.tween and S.isMoving do
        if curIndex < 1 or curIndex > #S.positionList then
            curIndex = 1
        end

        local pos = S.positionList[curIndex]
        if not (pos and pos.X and pos.Y and pos.Z) then
            Library:Notify(("Invalid pos @ %d"):format(curIndex))
            curIndex = (curIndex % #S.positionList) + 1
            task.wait(0.05)
            continue
        end

        local targetPos = Vector3.new(pos.X, pos.Y, pos.Z)
        local startPos = Root.Position
        local dist = (startPos - targetPos).Magnitude
        local speed = S.tweenSpeed
        local MAX_TRAVEL_SECS = math.max(20, dist / (speed * 0.5))
        local duration = math.max(0.1, dist / speed)

        if tweenConn then tweenConn:Disconnect(); tweenConn = nil end
        if tween then tween:Cancel(); tween = nil end

        if jumpOuter then continue end

        if restartToNext then
            fails[curIndex] = (fails[curIndex] or 0) + 1
            if fails[curIndex] >= 3 then
                fails[curIndex] = 0
            end
            curIndex = (curIndex % #S.positionList) + 1
            task.wait(0.15)
            continue
        end

        fails[curIndex] = 0
        rbCount[curIndex] = 0
        curIndex = (curIndex % #S.positionList) + 1
        
        task.wait(0.05)
    end
    
    task.wait(0.02)
    if tweenConn then tweenConn:Disconnect(); tweenConn = nil end
    if tween then tween:Cancel(); tween = nil end
end

repeat task.wait(0.1) until Library

local Window = Library:CreateWindow({
    Title = 'Gold Farm Hub',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Main'),
    Extras = Window:AddTab('Extras'),
    Performance = Window:AddTab('Performance'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local MainBox = Tabs.Main:AddLeftGroupbox('Main')

MainBox:AddButton('Anti-AFK', function()
    setupAntiAFK()
    Library:Notify('Anti-AFK enabled!')
end)

MainBox:AddToggle('AutoHit', {
    Text = 'Auto Hit',
    Default = false,
    Callback = function(v)
        S.autoHit = v
        if v then
            Connections.autoHit = RunService.Heartbeat:Connect(hitResources)
        else
            if Connections.autoHit then Connections.autoHit:Disconnect() end
        end
    end
})

MainBox:AddToggle('Noclip', {
    Text = 'Noclip',
    Default = false,
    Callback = function(v)
        S.noclip = v
        noclip()
        if v then
            Connections.noclip = RunService.Heartbeat:Connect(noclip)
        else
            if Connections.noclip then Connections.noclip:Disconnect() end
            noclip()
        end
    end
})

MainBox:AddDropdown('FruitSelect', {
    Values = fruitOptions,
    Default = 1,
    Multi = false,
    Text = 'Select Fruit',
    Callback = function(v) S.fruit = v end
})

MainBox:AddToggle('AutoEat', {
    Text = 'Auto Eat',
    Default = false,
    Callback = function(v)
        S.autoEat = v
        if v then Tasks.autoEat = task.spawn(autoEat)
        else if Tasks.autoEat then task.cancel(Tasks.autoEat) end end
    end
})

local TweenBox = Tabs.Main:AddRightGroupbox('Tweening')

TweenBox:AddLabel('YAKK TWEEN STARTS AT MID')
TweenBox:AddDivider()

TweenBox:AddDropdown('PathSelect', {
    Values = { "Path 1", "Draksies" },
    Default = 1,
    Multi = false,
    Text = 'Select Path',
    Callback = function(v) 
        S.selectedPath = v
        if v == "Path 1" then
            S.positionList = config.positions or {}
        else
            S.positionList = config2.positions or {}
        end
        Library:Notify('Switched to ' .. v)
    end
})

TweenBox:AddToggle('Tween', {
    Text = 'Enable Tween',
    Default = false,
    Callback = function(v)
        S.tween = v
        S.isMoving = v
        if v then
            task.wait(0.5)
            if S.selectedPath == "Path 1" then
                S.positionList = config.positions or {}
            else
                S.positionList = config2.positions or {}
            end
            Tasks.tween = task.spawn(startTweening)
        else
            if tween then tween:Cancel() tween = nil end
            if tweenConn then tweenConn:Disconnect() tweenConn = nil end
            if Tasks.tween then task.cancel(Tasks.tween) end
        end
    end
})

TweenBox:AddSlider('Speed', {
    Text = 'Tween Speed',
    Default = 19.6,
    Min = 5,
    Max = 50,
    Rounding = 1,
    Compact = false,
    Callback = function(v)
        S.tweenSpeed = v
    end
})

local PickupBox = Tabs.Main:AddLeftGroupbox('Instant Pickup')

PickupBox:AddToggle('PickupGold', {
    Text = 'Pickup Raw Gold',
    Default = false,
    Callback = function(v)
        S.pickupGold = v
        if v then Tasks.pickupGold = task.spawn(pickupGolds)
        else if Tasks.pickupGold then task.cancel(Tasks.pickupGold) end end
    end
})

PickupBox:AddToggle('PickupCoal', {
    Text = 'Pickup Coal',
    Default = false,
    Callback = function(v)
        S.pickupCoal = v
        if v then Tasks.pickupCoal = task.spawn(pickupCoals)
        else if Tasks.pickupCoal then task.cancel(Tasks.pickupCoal) end end
    end
})

PickupBox:AddToggle('PickupCoins', {
    Text = 'Pickup Coins',
    Default = false,
    Callback = function(v)
        S.pickupCoins = v
        if v then Tasks.pickupCoins = task.spawn(pickupCoins)
        else if Tasks.pickupCoins then task.cancel(Tasks.pickupCoins) end end
    end
})

local ExtrasBox = Tabs.Extras:AddLeftGroupbox('Extras')

ExtrasBox:AddToggle('CoinPress', {
    Text = 'Auto Coin Press (Fast)',
    Default = false,
    Tooltip = '10x burst, 6x faster',
    Callback = function(v)
        S.coinPress = v
        if v then Tasks.coinPress = task.spawn(pressCoins)
        else if Tasks.coinPress then task.cancel(Tasks.coinPress) end end
    end
})

ExtrasBox:AddToggle('CampfireFuel', {
    Text = 'Auto Fuel Campfire (2 Coal)',
    Default = false,
    Tooltip = 'Fuels with 2 coal when ≤10 fuel',
    Callback = function(v)
        S.campfireFuel = v
        if v then Tasks.campfireFuel = task.spawn(campfireRefuel)
        else if Tasks.campfireFuel then task.cancel(Tasks.campfireFuel) end end
    end
})

ExtrasBox:AddToggle('TPGoldToChest', {
    Text = 'TP Raw Gold to Chest',
    Default = false,
    Callback = function(v)
        S.tpRawGoldToChest = v
        if v then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then
                S.tpRawGoldToChest = false
                Library:Notify('No chest found!')
                return
            end
            Tasks.tpRawGold = task.spawn(tpRawGold)
        else
            if Tasks.tpRawGold then task.cancel(Tasks.tpRawGold) end
        end
    end
})

ExtrasBox:AddToggle('PickupGoldFromChest', {
    Text = 'Pickup Gold from Chest',
    Default = false,
    Callback = function(v)
        S.pickupGoldFromChest = v
        if v then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then
                S.pickupGoldFromChest = false
                Library:Notify('No chest found!')
                return
            end
            Tasks.pickupGoldFromChest = task.spawn(pickupGoldFromChest)
        else
            if Tasks.pickupGoldFromChest then task.cancel(Tasks.pickupGoldFromChest) end
        end
    end
})

local ToolBox = Tabs.Extras:AddRightGroupbox('Auto Retool')

ToolBox:AddDropdown('RetoolChoice', {
    Values = { "God Axe", "God Pick" },
    Default = 1,
    Multi = false,
    Text = 'Choose Tool',
    Callback = function(v) 
        S.retoolChoice = v
        Library:Notify('Selected: ' .. v)
    end
})

ToolBox:AddToggle('AutoRetool', {
    Text = 'Auto Retool',
    Default = false,
    Tooltip = 'Auto crafts and equips chosen tool',
    Callback = function(v)
        S.autoRetoolEnabled = v
        if v then
            if S.retoolThread then pcall(task.cancel, S.retoolThread) end
            S.retoolThread = task.spawn(autoRetoolLoop)
        else
            if S.retoolThread then pcall(task.cancel, S.retoolThread) end
            S.retoolThread = nil
        end
    end
})

ToolBox:AddLabel('Requires Gold & Crystal Chunk')
ToolBox:AddLabel('Will buy from shop if needed')

local PerfBox = Tabs.Performance:AddLeftGroupbox('Performance Boost')

PerfBox:AddLabel('Black Screen Mode')

PerfBox:AddToggle('BlackScreen', {
    Text = 'Enable Black Screen',
    Default = false,
    Tooltip = 'Covers screen with black overlay',
    Callback = function(v)
        S.blackScreen = v
        if v then
            enableBlackScreen()
            Library:Notify('Black Screen Enabled!')
        else
            disableBlackScreen()
            Library:Notify('Black Screen Disabled')
        end
    end
})

PerfBox:AddDivider()

PerfBox:AddToggle('HideItems', {
    Text = 'Hide Items on Floor',
    Default = false,
    Tooltip = 'Hides all items for better FPS',
    Callback = function(v)
        S.hideItems = v
        if v then
            hideItemsOnFloor()
            Connections.hideItems = RunService.Heartbeat:Connect(hideItemsOnFloor)
            Library:Notify('Items Hidden!')
        else
            if Connections.hideItems then 
                Connections.hideItems:Disconnect() 
                Connections.hideItems = nil
            end
            showItemsOnFloor()
            Library:Notify('Items Visible')
        end
    end
})

PerfBox:AddDivider()
PerfBox:AddLabel('Benefits:')
PerfBox:AddLabel('• Massive FPS increase')
PerfBox:AddLabel('• Reduced GPU usage')
PerfBox:AddLabel('• Lower CPU overhead')

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
ThemeManager:SetFolder('GoldFarmHub')
SaveManager:SetFolder('GoldFarmHub/configs')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])

Library:OnUnload(function()
    Library.Unloaded = true
    if S.blackScreen then
        disableBlackScreen()
    end
    if tween then
        tween:Cancel()
    end
    if tweenConn then
        tweenConn:Disconnect()
    end
end)

Library:Notify('Gold Farm Hub loaded!')

task.spawn(function()
    task.wait(2)
    if config.positions then
        S.positionList = config.positions
    end
end)ween = nil end

        local ti = TweenInfo.new(
            duration, 
            Enum.EasingStyle.Sine,
            Enum.EasingDirection.InOut
        )
        tween = TweenService:Create(Root, ti, { CFrame = CFrame.new(targetPos) })

        local completed, restartToNext, rubberbanded = false, false, false
        local jumpOuter = false

        local t0 = tick()
        local lastPoll = t0
        local lastPos = startPos
        local lastDist = (lastPos - targetPos).Magnitude

        tweenConn = tween.Completed:Connect(function()
            completed = true
            if tweenConn then tweenConn:Disconnect(); tweenConn = nil end
        end)

        tween:Play()

        while S.tween and S.isMoving and not completed do
            task.wait(JUMP_SAMPLE_SECS)

            local now = tick()
            local elapsed = now - t0
            local alpha = math.clamp(elapsed / duration, 0, 1)

            local curPos  = Root.Position
            local curDist = (curPos - targetPos).Magnitude

            if curDist <= REACH_RADIUS then
                completed = true
                break
            end

            local stepJump = (curPos - lastPos).Magnitude
            if (curDist - lastDist) >= TELEPORT_BACK_DINC or stepJump >= TELEPORT_STEP_JUMP then
                rubberbanded = true
            end

            do
                local expectPos = startPos:Lerp(targetPos, alpha)
                local dev = (curPos - expectPos).Magnitude
                if dev >= RUBBER_DEV_STUDS then
                    local vmag = Root.AssemblyLinearVelocity.Magnitude
                    if vmag < 1 or dev > (RUBBER_DEV_STUDS * 1.5) then
                        rubberbanded = true
                    end
                end
            end

            if (now - t0) > MAX_TRAVEL_SECS or 
               ((now - lastPoll) > NO_PROGRESS_SECS and (lastDist - curDist) < MIN_IMPROVE_STUDS) then
                restartToNext = true
                break
            end

            if rubberbanded then
                if tweenConn then tweenConn:Disconnect(); tweenConn = nil end
                if tween then tween:Cancel(); tween = nil end

                task.wait(SETTLE_SECS)
                local serverPos = Root.Position
                local newIndex  = nearestIndex(serverPos)

                rbCount[curIndex] = (rbCount[curIndex] or 0) + 1
                if rbCount[curIndex] >= MAX_RB_PER_NODE then
                    rbCount[curIndex] = 0
                    curIndex = (curIndex % #S.positionList) + 1
                else
                    curIndex = newIndex
                end

                task.wait(0.1)
                jumpOuter = true
                break
            end

            lastPoll = now
            lastDist = curDist
            lastPos = curPos
        end

        if tweenConn then tweenConn:Disconnect(); tweenConn = nil end
        if tween then tween:Cancel(); t
