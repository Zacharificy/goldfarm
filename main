local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local RS = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")

setthreadidentity(5)
local ClientAnimalReady = RS:WaitForChild("ClientAnimalReady")
local oldFire; oldFire = hookfunction(ClientAnimalReady.FireServer, function(...)
    if not checkcaller() and select(1, ...) == ClientAnimalReady then return nil end
    return oldFire(...)
end)

local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local Root = Character:WaitForChild("HumanoidRootPart")

Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)

local Packets = require(RS.Modules.Packets)
local GameUtil = require(RS.Modules.GameUtil)
local ItemIDS = require(RS.Modules.ItemIDS)
local ItemData = require(RS.Modules.ItemData)
local Clock = require(RS.Modules.Clock)
local Events = RS:WaitForChild("Events")
local SpawnFirst = Events:WaitForChild("SpawnFirst")

Player.CharacterAdded:Connect(function(char)
    Character = char
    Humanoid = char:WaitForChild("Humanoid")
    Root = char:WaitForChild("HumanoidRootPart")
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)
end)

local config = {waitTime = 0.01, positions = {}}
local config2 = {waitTime = 0.01, positions = {}}

task.spawn(function()
    local success, result = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Zacharificy/goldfarm/main/tweens"))()
    end)
    if success and result then config = result end
end)

task.spawn(function()
    local success, result = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Zacharificy/goldfarm/refs/heads/main/tweens2"))()
    end)
    if success and result then 
        if result.positions and type(result.positions[1]) == "table" and result.positions[1].positions then
            config2 = {waitTime = result.waitTime or 0.01, positions = result.positions[1].positions}
        else
            config2 = result 
        end
    end
end)

local S = {
    autoHit = false, noclip = false, autoEat = false, tween = false,
    pickupGold = false, pickupCoal = false, pickupCoins = false,
    coinPress = false, campfireFuel = false, tpRawGoldToChest = false,
    pickupGoldFromChest = false, blackScreen = false, fruit = "Lemon",
    hitRadius = 200, positionList = {}, tweenSpeed = 19, isMoving = false,
    lastEatTime = 0, chest = nil, CampfireTracker = {}, autoRetoolEnabled = false,
    retoolChoice = "God Pick", retoolThread = nil, hideItems = false,
    hiddenItems = {}, selectedPath = "Path 1", autoBedSpawnEnabled = false,
    autoSpawnConnection = nil, autoSpawnDeathConnection = nil,
    autoSpawnRemovingConnection = nil, tweenWasActive = false,
    autoHitWasActive = false, autoRetoolWasActive = false, died = false,
    walkSpeed = 19
}

local CFG = {
    GOLD_ID = 597, CRYSTAL_ID = 436, GOD_AXE_ID = 454, GOD_PICK_ID = 132,
    NEED_GOLD = 12, NEED_CRYSTAL = 3, HUNGER_CAP = 100, EAT_AT = 90, EAT_COOLDOWN = 1.5
}

local Connections, Tasks = {}, {}
local Cache = {
    Items = workspace:FindFirstChild("Items"),
    Resources = workspace:FindFirstChild("Resources"),
    Deployables = workspace:FindFirstChild("Deployables")
}

local fruitOptions = {}
task.spawn(function()
    for name, data in pairs(ItemData) do
        if data.grows then table.insert(fruitOptions, name) end
    end
    table.sort(fruitOptions)
end)

local GC = getconnections or get_signal_cons
if GC then
    for _, v in pairs(GC(Player.Idled)) do
        if v.Disable then v:Disable() elseif v.Disconnect then v:Disconnect() end
    end
else
    local VirtualUser = game:GetService("VirtualUser")
    Player.Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end)
end

local function idToName(id)
    for name, data in pairs(ItemData) do
        if type(data) == "table" and (data.id == id or data.itemID == id) then return name end
    end
    for name, _id in pairs(ItemIDS) do
        if _id == id then return name end
    end
    return nil
end

local function getQuantity(name)
    local success, data = pcall(function() return GameUtil.getData().inventory end)
    if not success or not data then return 0 end
    for _, v in pairs(data) do
        if v and v.name == name then return v.quantity or 0 end
    end
    return 0
end

local function chosenName() return (S.retoolChoice == "God Axe") and "God Axe" or "God Pick" end
local function chosenCraftID() return (S.retoolChoice == "God Axe") and CFG.GOD_AXE_ID or CFG.GOD_PICK_ID end
local function getToolbar() return (GameUtil and GameUtil.Data and GameUtil.Data.toolbar) or {} end
local function getEquipped() return GameUtil and GameUtil.Data and GameUtil.Data.equipped end

local function toolbarFindChosenSlot()
    for slot, entry in pairs(getToolbar()) do
        local name = entry and (entry.name or (entry.itemID and idToName(entry.itemID)))
        if name == chosenName() then return slot end
    end
    return nil
end

local function equippedIsChosen()
    local eq = getEquipped()
    if type(eq) == "number" then
        local e = getToolbar()[eq]
        local nm = e and (e.name or (e.itemID and idToName(e.itemID)))
        return nm == chosenName()
    elseif type(eq) == "string" then
        return eq == chosenName()
    elseif type(eq) == "table" then
        local nm = eq.name or (eq.itemID and idToName(eq.itemID))
        return nm == chosenName()
    end
    return false
end

local function ensureMaterials()
    local g, c = tonumber(getQuantity("Gold")) or 0, tonumber(getQuantity("Crystal Chunk")) or 0
    for i = 1, math.max(0, CFG.NEED_GOLD - g) do pcall(Packets.PurchaseFromShop.send, CFG.GOLD_ID) task.wait() end
    for i = 1, math.max(0, CFG.NEED_CRYSTAL - c) do pcall(Packets.PurchaseFromShop.send, CFG.CRYSTAL_ID) task.wait() end
end

local function craftAndEquipFromHotbar()
    ensureMaterials()
    pcall(Packets.CraftItem.send, chosenCraftID())
    task.wait(0.5)
    local t0, slot = os.clock()
    repeat slot = toolbarFindChosenSlot() if slot then break end task.wait(0.1) until os.clock() - t0 > 3
    if not slot then task.wait(0.3) slot = toolbarFindChosenSlot() end
    if slot then pcall(Packets.EquipTool.send, slot) return true
    else if Library then Library:Notify('Tool not found in hotbar') end return false end
end

local function autoRetoolLoop()
    while S.autoRetoolEnabled do
        task.wait(0.5)
        if not equippedIsChosen() then
            local slot = toolbarFindChosenSlot()
            if slot then pcall(Packets.EquipTool.send, slot) else pcall(craftAndEquipFromHotbar) end
        end
    end
end

local function hideItemsOnFloor()
    if not Cache.Items then return end
    for _, item in ipairs(Cache.Items:GetChildren()) do
        if not S.hiddenItems[item] then
            S.hiddenItems[item] = true
            for _, part in ipairs(item:GetDescendants()) do
                if part:IsA("BasePart") then part.Transparency = 1 part.CanCollide = false
                elseif part:IsA("Decal") or part:IsA("Texture") then part.Transparency = 1 end
            end
        end
    end
end

local function showItemsOnFloor()
    if not Cache.Items then return end
    for item in pairs(S.hiddenItems) do
        if item and item.Parent then
            for _, part in ipairs(item:GetDescendants()) do
                if part:IsA("BasePart") then part.Transparency = 0 part.CanCollide = true
                elseif part:IsA("Decal") or part:IsA("Texture") then part.Transparency = 0 end
            end
        end
    end
    table.clear(S.hiddenItems)
end

local hitDebounce = false
local function hitResources()
    if hitDebounce or not Root or not Root.Parent then return end
    hitDebounce = true
    local entities, rootPos, radiusSq = {}, Root.Position, S.hitRadius * S.hitRadius
    if Cache.Resources then
        for _, res in ipairs(Cache.Resources:GetChildren()) do
            if res.Parent then
                local ok, pivot = pcall(res.GetPivot, res)
                if ok and (rootPos - pivot.Position).Magnitude * (rootPos - pivot.Position).Magnitude <= radiusSq then
                    local id = res:GetAttribute("EntityID")
                    if id then entities[#entities + 1] = id end
                end
            end
        end
    end
    if #entities > 0 then pcall(Packets.SwingTool.send, entities) end
    task.delay(0.06, function() hitDebounce = false end)
end

local function noclip()
    if Cache.Deployables then
        for _, v in ipairs(Cache.Deployables:GetChildren()) do
            local door = v:FindFirstChild("Door")
            if door then door.Transparency = S.noclip and 0.5 or 0 door.CanCollide = not S.noclip end
        end
    end
    if S.noclip and Character then
        for _, part in ipairs(Character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then part.CanCollide = false end
        end
    end
end

local function findFruit(name)
    local success, data = pcall(function() return GameUtil.getData().inventory end)
    if not success or not data then return nil end
    for idx, item in pairs(data) do
        if item and item.name == name then return idx end
    end
    return nil
end

local function getHunger()
    local stats = GameUtil and GameUtil.Data and GameUtil.Data.stats
    return stats and stats.food
end

local function autoEat()
    while S.autoEat do
        local hunger = getHunger()
        if S.fruit and hunger and hunger <= CFG.EAT_AT and (tick() - S.lastEatTime) >= CFG.EAT_COOLDOWN then
            local idx = findFruit(S.fruit)
            if idx then pcall(Packets.UseBagItem.send, idx) S.lastEatTime = tick() end
        end
        task.wait(0.8)
    end
end

local function createPickup(itemName, checkChests, stateKey)
    return function()
        local cache = {}
        while S[stateKey] do
            if Cache.Items then
                for _, item in ipairs(Cache.Items:GetChildren()) do
                    if item.Name == itemName and not cache[item] then
                        local id = item:GetAttribute("EntityID")
                        if id then
                            cache[item] = true
                            for i = 1, 10 do pcall(Packets.Pickup.send, id) end
                            task.delay(0.3, function() cache[item] = nil end)
                        end
                    end
                end
            end
            if checkChests and Cache.Deployables then
                for _, chest in ipairs(Cache.Deployables:GetChildren()) do
                    local contents = chest:FindFirstChild("Contents")
                    if contents then
                        for _, item in ipairs(contents:GetChildren()) do
                            if item.Name == itemName and not cache[item] then
                                local id = item:GetAttribute("EntityID")
                                if id then
                                    cache[item] = true
                                    for i = 1, 10 do pcall(Packets.Pickup.send, id) end
                                    task.delay(0.3, function() cache[item] = nil end)
                                end
                            end
                        end
                    end
                end
            end
            RunService.Heartbeat:Wait()
        end
    end
end

local pickupGolds = createPickup("Raw Gold", false, "pickupGold")
local pickupCoals = createPickup("Coal", false, "pickupCoal")
local pickupCoins = createPickup("Coin", false, "pickupCoins")

local function getDeployable(name, range)
    if not Cache.Deployables or not Root then return nil end
    local closest, closestDist, rootPos = nil, range or math.huge, Root.Position
    for _, v in ipairs(Cache.Deployables:GetChildren()) do
        if v.Name == name and v:IsA("Model") then
            local ok, pivot = pcall(v.GetPivot, v)
            if ok then
                local dist = (rootPos - pivot.Position).Magnitude
                if dist < closestDist then closest, closestDist = v, dist end
            end
        end
    end
    return closest
end

local function GetDeployable(name, range, multiple)
    local deployablesFolder = Cache.Deployables
    if not deployablesFolder or not Root then return multiple and {} or nil end
    range = tonumber(range) or math.huge
    if multiple then
        local results = {}
        for _, v in ipairs(deployablesFolder:GetChildren()) do
            if v.Name == name and v:IsA("Model") then
                local ok, pivot = pcall(function() return v:GetPivot() end)
                if ok and pivot then
                    local dist = (Root.Position - pivot.Position).Magnitude
                    if dist < range then table.insert(results, { deployable = v, range = dist }) end
                end
            end
        end
        table.sort(results, function(a, b) return a.range < b.range end)
        return results
    else
        return getDeployable(name, range)
    end
end

local function pressCoins()
    local press, entityID, lastLookup, lastSend = nil, nil, 0, 0
    while S.coinPress do
        local now = os.clock()
        if (not press or not press.Parent or (now - lastLookup) >= 2) then
            press = getDeployable("Coin Press", 25)
            entityID = (press and press:GetAttribute("EntityID")) or nil
            lastLookup = now
        end
        if entityID then
            local goldAmt = getQuantity("Gold") or 0
            if goldAmt > 0 and (now - lastSend) >= 0.01 then
                for i = 1, math.min(goldAmt, 10) do
                    pcall(Packets.InteractStructure.send, { entityID = entityID, itemID = ItemIDS.Gold })
                end
                lastSend = now
            end
        end
        RunService.Heartbeat:Wait()
    end
end

local function getFuelBurnValue(fuelName)
    local data = ItemData[fuelName]
    return data and data.fuelValue or 60
end

local function GetFuel()
    local success, data = pcall(function() return GameUtil.getData().inventory end)
    if not success or not data then return nil end
    for x, v in pairs(data) do
        if v and v.name and ItemData[v.name] and ItemData[v.name]["fuels"] then return ItemIDS[v.name] end
    end
    return nil
end

local function campfireRefuel()
    while S.campfireFuel do
        task.wait(1)
        local currentTime, campfires = tick(), GetDeployable("Campfire", 40, true) or {}
        for trackedCampfire in pairs(S.CampfireTracker) do
            if not trackedCampfire.Parent then S.CampfireTracker[trackedCampfire] = nil end
        end
        for _, rec in ipairs(campfires) do
            local campfire, tracked, remainingFuel = rec.deployable, S.CampfireTracker[campfire], 0
            if tracked then
                local elapsed = currentTime - tracked.lastFuelTime
                remainingFuel = math.max(0, tracked.fuelAmount - elapsed)
            end
            if remainingFuel <= 10 then
                local fuel = GetFuel()
                if fuel then
                    local entityID = campfire:GetAttribute("EntityID")
                    if entityID then
                        local fuelName = idToName(fuel)
                        if not fuelName then continue end
                        local fuelValue = getFuelBurnValue(fuelName)
                        for i = 1, 2 do
                            pcall(Packets.InteractStructure.send, { entityID = entityID, itemID = fuel })
                            task.wait(0.05)
                        end
                        S.CampfireTracker[campfire] = { lastFuelTime = currentTime, fuelAmount = fuelValue * 2 }
                        task.wait(0.2)
                    end
                end
            end
        end
    end
    table.clear(S.CampfireTracker)
end

local function tpRawGold()
    while S.tpRawGoldToChest do
        if not S.chest or not S.chest.Parent then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then task.wait(0.3) continue end
        end
        local success, inventory = pcall(function() return GameUtil.getData().inventory end)
        if success and inventory then
            for idx, data in pairs(inventory) do
                if data and data.name == "Raw Gold" and data.quantity > 0 then
                    for i = 1, math.min(data.quantity, 100) do pcall(Packets.DropBagItem.send, idx, 1) end
                    task.wait(0.02)
                    if Cache.Items then
                        for _, item in ipairs(Cache.Items:GetChildren()) do
                            if item.Name == "Raw Gold" then
                                local id = item:GetAttribute("EntityID")
                                if id and S.chest and S.chest.Parent then
                                    pcall(Packets.ForceInteract.send, id)
                                    pcall(item.PivotTo, item, S.chest:GetPivot() * CFrame.new(0, 2, 0))
                                    pcall(Packets.ForceInteract.send)
                                end
                            end
                        end
                    end
                    break
                end
            end
        end
        RunService.Heartbeat:Wait()
    end
end

local function pickupGoldFromChest()
    while S.pickupGoldFromChest do
        if not S.chest or not S.chest.Parent then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then task.wait(0.5) continue end
        end
        local contents = S.chest:FindFirstChild("Contents")
        if contents then
            for _, item in ipairs(contents:GetChildren()) do
                if item.Name == "Gold" then
                    local id = item:GetAttribute("EntityID")
                    if id then for i = 1, 10 do pcall(Packets.Pickup.send, id) end end
                end
            end
        end
        RunService.Heartbeat:Wait()
    end
end

local blackScreenGui, originalLighting = nil, {}

local function enableBlackScreen()
    if not blackScreenGui then
        blackScreenGui = Instance.new("ScreenGui")
        blackScreenGui.Name = "BlackScreenOptimizer"
        blackScreenGui.IgnoreGuiInset = true
        blackScreenGui.ResetOnSpawn = false
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundColor3 = Color3.new(0, 0, 0)
        frame.BorderSizePixel = 0
        frame.Parent = blackScreenGui
        blackScreenGui.Parent = Player:WaitForChild("PlayerGui")
    end
    originalLighting = {
        Brightness = Lighting.Brightness, GlobalShadows = Lighting.GlobalShadows,
        OutdoorAmbient = Lighting.OutdoorAmbient, Ambient = Lighting.Ambient,
    }
    Lighting.Brightness = 0
    Lighting.GlobalShadows = false
    Lighting.OutdoorAmbient = Color3.new(0, 0, 0)
    Lighting.Ambient = Color3.new(0, 0, 0)
    for _, effect in pairs(Lighting:GetChildren()) do
        if effect:IsA("PostEffect") then effect.Enabled = false end
    end
end

local function disableBlackScreen()
    if blackScreenGui then blackScreenGui:Destroy() blackScreenGui = nil end
    if originalLighting.Brightness then
        Lighting.Brightness = originalLighting.Brightness
        Lighting.GlobalShadows = originalLighting.GlobalShadows
        Lighting.OutdoorAmbient = originalLighting.OutdoorAmbient
        Lighting.Ambient = originalLighting.Ambient
    end
    for _, effect in pairs(Lighting:GetChildren()) do
        if effect:IsA("PostEffect") then effect.Enabled = true end
    end
end

local function waitForGameLoad()
    local PlayerGui = Player:WaitForChild("PlayerGui")
    local SpawnGui = PlayerGui:WaitForChild("SpawnGui", 10)
    if not SpawnGui then return false end
    return true, SpawnGui, SpawnFirst
end

local function autoSpawn()
    if Player:GetAttribute("hasSpawned") then return end
    local ok, SpawnGui, SpawnFirst = waitForGameLoad()
    if not ok then return end
    local waited = 0
    while not SpawnGui.Enabled and waited < 5 do task.wait(0.1) waited = waited + 0.1 end
    if not SpawnGui.Enabled then return end
    task.wait(1.5)
    if Player:GetAttribute("hasSpawned") then return end
    
    if getconnections then
        local bedButton = SpawnGui:FindFirstChild("Customization")
        if bedButton then bedButton = bedButton:FindFirstChild("BedButton") end
        if bedButton then
            local clicked = false
            for _, conn in pairs(getconnections(bedButton.Activated)) do
                if conn.Function and conn.Enabled then
                    local succ = pcall(function() conn:Fire() end)
                    if succ then clicked = true task.wait(0.5) break end
                end
            end
            if not clicked then
                for _, conn in pairs(getconnections(bedButton.MouseButton1Click)) do
                    if conn.Function and conn.Enabled then
                        local succ = pcall(function() conn:Fire() end)
                        if succ then clicked = true task.wait(0.5) break end
                    end
                end
            end
            if clicked then
                task.wait(0.5)
                if Player:GetAttribute("hasSpawned") then return end
            end
        end
    end

    Player:SetAttribute("hasSpawned", false)
    task.wait(0.3)
    local success, result1, result2 = pcall(function() return SpawnFirst:InvokeServer(true) end)
    if success and result1 then
        Player:SetAttribute("hasSpawned", true)
        if result2 then GameUtil.Data.lastSpawnFromBed = result2 end
        SpawnGui.Enabled = false
        local PG = Player:WaitForChild("PlayerGui")
        local MainGui = PG:FindFirstChild("MainGui")
        if MainGui then MainGui.Enabled = true end
        local Topbar = PG:FindFirstChild("Topbar")
        if Topbar then Topbar.Enabled = true end
        local cam = workspace.CurrentCamera
        cam.CameraType = Enum.CameraType.Custom
        local char = Player.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum then cam.CameraSubject = hum end
    end
end

local tween, tweenConn = nil, nil

local function startTweening()
    if #S.positionList == 0 then
        if Library then Library:Notify('No positions available') end
        return
    end

    if not Root or not Root.Parent then
        if Library then Library:Notify('Character not ready') end
        return
    end

    local function nearestIndex(fromPos)
        if not fromPos then return 1 end
        local bestI, bestD = 1, math.huge
        for j = 1, #S.positionList do
            local p = S.positionList[j]
            if p and type(p) == "table" and p.X and p.Y and p.Z then
                local x, y, z = tonumber(p.X) or 0, tonumber(p.Y) or 0, tonumber(p.Z) or 0
                local d = (fromPos - Vector3.new(x, y, z)).Magnitude
                if d < bestD then bestI, bestD = j, d end
            end
        end
        return bestI
    end

    local curIndex = nearestIndex(Root.Position)

    while S.tween and S.isMoving do
        if not Root or not Root.Parent then break end
        if curIndex < 1 or curIndex > #S.positionList then curIndex = 1 end

        local pos = S.positionList[curIndex]
        if not (pos and type(pos) == "table" and pos.X and pos.Y and pos.Z) then
            curIndex = (curIndex % #S.positionList) + 1
            task.wait(0.05)
            continue
        end

        local x, y, z = tonumber(pos.X), tonumber(pos.Y), tonumber(pos.Z)
        if not (x and y and z) then
            curIndex = (curIndex % #S.positionList) + 1
            task.wait(0.05)
            continue
        end

        local targetPos = Vector3.new(x, y, z)
        local startPos = Root.Position
        local dist = (startPos - targetPos).Magnitude
        local speed = tonumber(S.walkSpeed) or 19
        local duration = math.max(0.1, dist / speed)

        if tweenConn then tweenConn:Disconnect() tweenConn = nil end
        if tween then tween:Cancel() tween = nil end

        -- Use Quad easing for smoother acceleration/deceleration
        local ti = TweenInfo.new(
            duration, 
            Enum.EasingStyle.Quad,
            Enum.EasingDirection.InOut
        )
        tween = TweenService:Create(Root, ti, { CFrame = CFrame.new(targetPos) })

        local completed = false
        tweenConn = tween.Completed:Connect(function()
            completed = true
            if tweenConn then tweenConn:Disconnect() tweenConn = nil end
        end)

        tween:Play()

        -- Improved progress checking with more frequent updates
        local checkInterval = 0.1
        local maxChecks = math.ceil(duration / checkInterval) + 10
        local checks = 0
        local stuckCounter = 0
        local lastPosition = Root.Position
        
        while S.tween and S.isMoving and not completed and checks < maxChecks do
            task.wait(checkInterval)
            checks = checks + 1
            
            if not Root or not Root.Parent then break end
            
            -- Check if we've reached the target
            local curDist = (Root.Position - targetPos).Magnitude
            if curDist <= 4 then
                completed = true
                break
            end
            
            -- Detect if character is stuck (not moving)
            local movementDelta = (Root.Position - lastPosition).Magnitude
            if movementDelta < 0.5 then
                stuckCounter = stuckCounter + 1
                if stuckCounter >= 3 then
                    -- Skip to next waypoint if stuck
                    completed = true
                    break
                end
            else
                stuckCounter = 0
            end
            
            lastPosition = Root.Position
        end

        if tweenConn then tweenConn:Disconnect() tweenConn = nil end
        if tween then tween:Cancel() tween = nil end

        -- Brief pause between waypoints for stability
        task.wait(0.05)
        
        curIndex = (curIndex % #S.positionList) + 1
    end
    
    if tweenConn then tweenConn:Disconnect() tweenConn = nil end
    if tween then tween:Cancel() tween = nil end
end

local function setupAutoBedSpawn()
    if S.autoSpawnConnection then S.autoSpawnConnection:Disconnect() S.autoSpawnConnection = nil end
    if S.autoSpawnDeathConnection then S.autoSpawnDeathConnection:Disconnect() S.autoSpawnDeathConnection = nil end
    if S.autoSpawnRemovingConnection then S.autoSpawnRemovingConnection:Disconnect() S.autoSpawnRemovingConnection = nil end
    
    S.autoSpawnRemovingConnection = Player.CharacterRemoving:Connect(function()
        Player:SetAttribute("hasSpawned", false)
        S.tweenWasActive = S.tween
        S.autoHitWasActive = S.autoHit
        S.autoRetoolWasActive = S.autoRetoolEnabled
        S.died = true
    end)
    
    local function setupDeathDetection()
        if Player.Character then
            local humanoid = Player.Character:FindFirstChild("Humanoid")
            if humanoid then
                if S.autoSpawnDeathConnection then S.autoSpawnDeathConnection:Disconnect() end
                S.autoSpawnDeathConnection = humanoid.Died:Connect(function()
                    Player:SetAttribute("hasSpawned", false)
                    S.tweenWasActive = S.tween
                    S.autoHitWasActive = S.autoHit
                    S.autoRetoolWasActive = S.autoRetoolEnabled
                    S.died = true
                end)
            end
        end
    end
    
    S.autoSpawnConnection = Player.CharacterAdded:Connect(function(char)
        Character = char
        Humanoid = char:WaitForChild("Humanoid")
        Root = char:WaitForChild("HumanoidRootPart")
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)
        Player:SetAttribute("hasSpawned", false)
        setupDeathDetection()
        task.wait(0.5)
        
        if S.autoBedSpawnEnabled then
            task.spawn(autoSpawn)
            task.wait(3)
            
            if S.died then
                if S.autoRetoolWasActive then
                    S.autoRetoolEnabled = true
                    if S.retoolThread then pcall(task.cancel, S.retoolThread) end
                    task.wait(0.5)
                    pcall(craftAndEquipFromHotbar)
                    task.wait(0.5)
                    S.retoolThread = task.spawn(autoRetoolLoop)
                end
                
                if S.autoHitWasActive then
                    S.autoHit = true
                    Connections.autoHit = RunService.Heartbeat:Connect(hitResources)
                end
                
                if S.tweenWasActive then
                    task.wait(1)
                    S.tween = true
                    S.isMoving = true
                    Tasks.tween = task.spawn(startTweening)
                end
                S.died = false
            end
        end
    end)
    
    setupDeathDetection()
    Player:SetAttribute("hasSpawned", false)
end

repeat task.wait(0.1) until Library

local Window = Library:CreateWindow({
    Title = 'Gold Farm Hub',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Main'),
    Extras = Window:AddTab('Extras'),
    Performance = Window:AddTab('Performance'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local MainBox = Tabs.Main:AddLeftGroupbox('Main')

MainBox:AddToggle('AutoHit', {
    Text = 'Auto Hit',
    Default = false,
    Callback = function(v)
        S.autoHit = v
        if v then Connections.autoHit = RunService.Heartbeat:Connect(hitResources)
        else if Connections.autoHit then Connections.autoHit:Disconnect() end end
    end
})

MainBox:AddToggle('Noclip', {
    Text = 'Noclip',
    Default = false,
    Callback = function(v)
        S.noclip = v
        noclip()
        if v then Connections.noclip = RunService.Heartbeat:Connect(noclip)
        else if Connections.noclip then Connections.noclip:Disconnect() end noclip() end
    end
})

local fruitDropdown = MainBox:AddDropdown('FruitSelect', {
    Values = fruitOptions,
    Default = 1,
    Multi = false,
    Text = 'Select Fruit',
    Callback = function(v) S.fruit = v end
})

task.spawn(function()
    task.wait(2)
    for i, fruit in ipairs(fruitOptions) do
        if fruit == "Lemon" then
            fruitDropdown:SetValue(fruit)
            break
        end
    end
end)

MainBox:AddToggle('AutoEat', {
    Text = 'Auto Eat',
    Default = false,
    Callback = function(v)
        S.autoEat = v
        if v then Tasks.autoEat = task.spawn(autoEat)
        else if Tasks.autoEat then task.cancel(Tasks.autoEat) end end
    end
})

local TweenBox = Tabs.Main:AddRightGroupbox('Tweening')

TweenBox:AddDropdown('PathSelect', {
    Values = { "Path 1", "Draksies" },
    Default = 1,
    Multi = false,
    Text = 'Select Path',
    Callback = function(v) 
        S.selectedPath = v
        S.positionList = v == "Path 1" and (config.positions or {}) or (config2.positions or {})
        Library:Notify('Switched to ' .. v)
    end
})

TweenBox:AddToggle('Tween', {
    Text = 'Enable Tween',
    Default = false,
    Callback = function(v)
        S.tween = v
        S.isMoving = v
        if v then
            task.wait(0.5)
            S.positionList = S.selectedPath == "Path 1" and (config.positions or {}) or (config2.positions or {})
            if #S.positionList == 0 then
                Library:Notify('No positions loaded')
                S.tween = false
                S.isMoving = false
                return
            end
            Tasks.tween = task.spawn(startTweening)
        else
            if tween then tween:Cancel() tween = nil end
            if tweenConn then tweenConn:Disconnect() tweenConn = nil end
            if Tasks.tween then task.cancel(Tasks.tween) end
        end
    end
})

TweenBox:AddSlider('Speed', {
    Text = 'Tween Speed',
    Default = 19,
    Min = 5,
    Max = 30,
    Rounding = 1,
    Compact = false,
    Callback = function(v) S.walkSpeed = v end
})

local PickupBox = Tabs.Main:AddLeftGroupbox('Instant Pickup')

PickupBox:AddToggle('PickupGold', {
    Text = 'Pickup Raw Gold',
    Default = false,
    Callback = function(v)
        S.pickupGold = v
        if v then Tasks.pickupGold = task.spawn(pickupGolds)
        else if Tasks.pickupGold then task.cancel(Tasks.pickupGold) end end
    end
})

PickupBox:AddToggle('PickupCoal', {
    Text = 'Pickup Coal',
    Default = false,
    Callback = function(v)
        S.pickupCoal = v
        if v then Tasks.pickupCoal = task.spawn(pickupCoals)
        else if Tasks.pickupCoal then task.cancel(Tasks.pickupCoal) end end
    end
})

PickupBox:AddToggle('PickupCoins', {
    Text = 'Pickup Coins',
    Default = false,
    Callback = function(v)
        S.pickupCoins = v
        if v then Tasks.pickupCoins = task.spawn(pickupCoins)
        else if Tasks.pickupCoins then task.cancel(Tasks.pickupCoins) end end
    end
})

local ExtrasBox = Tabs.Extras:AddLeftGroupbox('Extras')

ExtrasBox:AddToggle('CoinPress', {
    Text = 'Auto Coin Press',
    Default = false,
    Callback = function(v)
        S.coinPress = v
        if v then Tasks.coinPress = task.spawn(pressCoins)
        else if Tasks.coinPress then task.cancel(Tasks.coinPress) end end
    end
})

ExtrasBox:AddToggle('CampfireFuel', {
    Text = 'Auto Fuel Campfire',
    Default = false,
    Callback = function(v)
        S.campfireFuel = v
        if v then Tasks.campfireFuel = task.spawn(campfireRefuel)
        else if Tasks.campfireFuel then task.cancel(Tasks.campfireFuel) end end
    end
})

ExtrasBox:AddToggle('TPGoldToChest', {
    Text = 'TP Raw Gold to Chest',
    Default = false,
    Callback = function(v)
        S.tpRawGoldToChest = v
        if v then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then
                S.tpRawGoldToChest = false
                Library:Notify('No chest found!')
                return
            end
            Tasks.tpRawGold = task.spawn(tpRawGold)
        else
            if Tasks.tpRawGold then task.cancel(Tasks.tpRawGold) end
        end
    end
})

ExtrasBox:AddToggle('PickupGoldFromChest', {
    Text = 'Pickup Gold from Chest',
    Default = false,
    Callback = function(v)
        S.pickupGoldFromChest = v
        if v then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then
                S.pickupGoldFromChest = false
                Library:Notify('No chest found!')
                return
            end
            Tasks.pickupGoldFromChest = task.spawn(pickupGoldFromChest)
        else
            if Tasks.pickupGoldFromChest then task.cancel(Tasks.pickupGoldFromChest) end
        end
    end
})

local ToolBox = Tabs.Extras:AddRightGroupbox('Auto Retool')

ToolBox:AddDropdown('RetoolChoice', {
    Values = { "God Axe", "God Pick" },
    Default = 2,
    Multi = false,
    Text = 'Choose Tool',
    Callback = function(v) 
        S.retoolChoice = v
        Library:Notify('Selected: ' .. v)
    end
})

ToolBox:AddToggle('AutoRetool', {
    Text = 'Auto Retool',
    Default = false,
    Callback = function(v)
        S.autoRetoolEnabled = v
        if v then
            if S.retoolThread then pcall(task.cancel, S.retoolThread) end
            S.retoolThread = task.spawn(autoRetoolLoop)
        else
            if S.retoolThread then pcall(task.cancel, S.retoolThread) end
            S.retoolThread = nil
        end
    end
})

local SpawnBox = Tabs.Extras:AddLeftGroupbox('Auto Bed Spawn')

SpawnBox:AddToggle('AutoBedSpawn', {
    Text = 'Enable Auto Bed Spawn',
    Default = false,
    Callback = function(v)
        S.autoBedSpawnEnabled = v
        if v then
            setupAutoBedSpawn()
            Library:Notify('Auto Bed Spawn Enabled')
        else
            if S.autoSpawnConnection then S.autoSpawnConnection:Disconnect() S.autoSpawnConnection = nil end
            if S.autoSpawnDeathConnection then S.autoSpawnDeathConnection:Disconnect() S.autoSpawnDeathConnection = nil end
            if S.autoSpawnRemovingConnection then S.autoSpawnRemovingConnection:Disconnect() S.autoSpawnRemovingConnection = nil end
            Library:Notify('Auto Bed Spawn Disabled')
        end
    end
})

local PerfBox = Tabs.Performance:AddLeftGroupbox('Performance Boost')

PerfBox:AddToggle('BlackScreen', {
    Text = 'Enable Black Screen',
    Default = false,
    Callback = function(v)
        S.blackScreen = v
        if v then enableBlackScreen() Library:Notify('Black Screen Enabled')
        else disableBlackScreen() Library:Notify('Black Screen Disabled') end
    end
})

PerfBox:AddToggle('HideItems', {
    Text = 'Hide Items on Floor',
    Default = false,
    Callback = function(v)
        S.hideItems = v
        if v then
            hideItemsOnFloor()
            Connections.hideItems = RunService.Heartbeat:Connect(hideItemsOnFloor)
            Library:Notify('Items Hidden')
        else
            if Connections.hideItems then Connections.hideItems:Disconnect() Connections.hideItems = nil end
            showItemsOnFloor()
            Library:Notify('Items Visible')
        end
    end
})

local UIBox = Tabs['UI Settings']:AddRightGroupbox('Script Control')

UIBox:AddButton({
    Text = 'Unload Script',
    Func = function()
        Library:Notify('Unloading...')
        task.wait(1)
        Library:Unload()
    end,
    DoubleClick = false
})

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
ThemeManager:SetFolder('GoldFarmHub')
SaveManager:SetFolder('GoldFarmHub/configs')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])

Library:OnUnload(function()
    Library.Unloaded = true
    
    if S.autoBedSpawnEnabled then
        if S.autoSpawnConnection then S.autoSpawnConnection:Disconnect() end
        if S.autoSpawnDeathConnection then S.autoSpawnDeathConnection:Disconnect() end
        if S.autoSpawnRemovingConnection then S.autoSpawnRemovingConnection:Disconnect() end
    end
    
    if S.blackScreen then disableBlackScreen() end
    if tween then tween:Cancel() end
    if tweenConn then tweenConn:Disconnect() end
    
    for _, conn in pairs(Connections) do
        if conn and conn.Disconnect then pcall(conn.Disconnect, conn) end
    end
    
    for _, task in pairs(Tasks) do
        if task then pcall(task.cancel, task) end
    end
end)

Library:Notify('Gold Farm Hub loaded')

task.spawn(function()
    task.wait(3)
    if config.positions and #config.positions > 0 then 
        S.positionList = config.positions 
    end
end)
