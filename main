local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local RS = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")

setthreadidentity(5)
local ClientAnimalReady = RS:WaitForChild("ClientAnimalReady")
local oldFire; oldFire = hookfunction(ClientAnimalReady.FireServer, function(...)
    if not checkcaller() and select(1, ...) == ClientAnimalReady then return nil end
    return oldFire(...)
end)

local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local Root = Character:WaitForChild("HumanoidRootPart")

Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)

local Packets = require(RS.Modules.Packets)
local GameUtil = require(RS.Modules.GameUtil)
local ItemIDS = require(RS.Modules.ItemIDS)
local ItemData = require(RS.Modules.ItemData)

Player.CharacterAdded:Connect(function(char)
    Character = char
    Humanoid = char:WaitForChild("Humanoid")
    Root = char:WaitForChild("HumanoidRootPart")
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)
end)

local config = {waitTime = 0.01, positions = {}}
task.spawn(function()
    local success, result = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Zacharificy/goldfarm/main/tweens"))()
    end)
    if success and result then config = result end
end)

local S = {
    autoHit = false,
    noclip = false,
    autoEat = false,
    tween = false,
    pickupGold = false,
    pickupCoal = false,
    pickupCoins = false,
    coinPress = false,
    campfireFuel = false,
    tpRawGoldToChest = false,
    pickupGoldFromChest = false,
    blackScreen = false,
    fruit = "Lemon",
    hitRadius = 200,
    waitTime = 0.01,
    positions = {},
    tweenSpeed = 20,
    isMoving = false,
    lastEatTime = 0,
    chest = nil
}

local HUNGER_CAP = 100
local EAT_AT = 90
local EAT_COOLDOWN = 1.5

local Connections = {}
local Tasks = {}
local Cache = {
    Items = workspace:FindFirstChild("Items"),
    Resources = workspace:FindFirstChild("Resources"),
    Deployables = workspace:FindFirstChild("Deployables")
}

local fruitOptions = {}
task.spawn(function()
    for name, data in pairs(ItemData) do
        if data.grows then table.insert(fruitOptions, name) end
    end
    table.sort(fruitOptions)
end)

local function setupAntiAFK()
    local GC = getconnections or get_signal_cons
    if GC then
        for _, v in pairs(GC(Player.Idled)) do
            if v.Disable then v:Disable() elseif v.Disconnect then v:Disconnect() end
        end
    else
        local VirtualUser = game:GetService("VirtualUser")
        Player.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end
end

local hitDebounce = false
local function hitResources()
    if hitDebounce or not Root.Parent then return end
    hitDebounce = true
    
    local entities = {}
    local rootPos = Root.Position
    local radiusSq = S.hitRadius * S.hitRadius
    
    if Cache.Resources then
        for _, res in ipairs(Cache.Resources:GetChildren()) do
            if res.Parent then
                local ok, pivot = pcall(res.GetPivot, res)
                if ok then
                    local dist = (rootPos - pivot.Position).Magnitude
                    if dist * dist <= radiusSq then
                        local id = res:GetAttribute("EntityID")
                        if id then entities[#entities + 1] = id end
                    end
                end
            end
        end
    end
    
    if #entities > 0 then pcall(Packets.SwingTool.send, entities) end
    task.delay(0.06, function() hitDebounce = false end)
end

local function noclip()
    if Cache.Deployables then
        for _, v in ipairs(Cache.Deployables:GetChildren()) do
            local door = v:FindFirstChild("Door")
            if door then
                door.Transparency = S.noclip and 0.5 or 0
                door.CanCollide = not S.noclip
            end
        end
    end
    
    if S.noclip and Character then
        for _, part in ipairs(Character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = false
            end
        end
    end
end

local function findFruit(name)
    for idx, data in next, GameUtil.getData().inventory do
        if data.name == name then return idx end
    end
end

local function getHunger()
    local stats = GameUtil and GameUtil.Data and GameUtil.Data.stats
    return stats and stats.food
end

local function autoEat()
    while S.autoEat do
        local hunger = getHunger()
        if S.fruit and hunger and hunger <= EAT_AT and (tick() - S.lastEatTime) >= EAT_COOLDOWN then
            local idx = findFruit(S.fruit)
            if idx then
                Packets.UseBagItem.send(idx)
                S.lastEatTime = tick()
            end
        end
        task.wait(0.8)
    end
end

local function createPickup(itemName, checkChests, stateKey)
    return function()
        local cache = {}
        while S[stateKey] do
            if Cache.Items then
                for _, item in ipairs(Cache.Items:GetChildren()) do
                    if item.Name == itemName and not cache[item] then
                        local id = item:GetAttribute("EntityID")
                        if id then
                            cache[item] = true
                            for i = 1, 3 do Packets.Pickup.send(id) end
                            task.delay(0.5, function() cache[item] = nil end)
                        end
                    end
                end
            end
            
            if checkChests and Cache.Deployables then
                for _, chest in ipairs(Cache.Deployables:GetChildren()) do
                    local contents = chest:FindFirstChild("Contents")
                    if contents then
                        for _, item in ipairs(contents:GetChildren()) do
                            if item.Name == itemName and not cache[item] then
                                local id = item:GetAttribute("EntityID")
                                if id then
                                    cache[item] = true
                                    for i = 1, 3 do Packets.Pickup.send(id) end
                                    task.delay(0.5, function() cache[item] = nil end)
                                end
                            end
                        end
                    end
                end
            end
            RunService.Heartbeat:Wait()
        end
    end
end

local pickupGolds = createPickup("Raw Gold", false, "pickupGold")
local pickupCoals = createPickup("Coal", false, "pickupCoal")
local pickupCoins = createPickup("Coin", false, "pickupCoins")

local function getDeployable(name, range)
    if not Cache.Deployables or not Root then return nil end
    
    local closest, closestDist = nil, range or math.huge
    local rootPos = Root.Position
    
    for _, v in ipairs(Cache.Deployables:GetChildren()) do
        if v.Name == name and v:IsA("Model") then
            local ok, pivot = pcall(v.GetPivot, v)
            if ok then
                local dist = (rootPos - pivot.Position).Magnitude
                if dist < closestDist then
                    closest, closestDist = v, dist
                end
            end
        end
    end
    return closest
end

local function getQuantity(name)
    for _, v in next, GameUtil.getData().inventory do
        if v.name == name then return v.quantity end
    end
    return 0
end

local function pressCoins()
    local press, entityID = nil, nil
    while S.coinPress do
        if not press or not press.Parent then
            press = getDeployable("Coin Press", 25)
            entityID = press and press:GetAttribute("EntityID")
            if not entityID then task.wait(0.5) continue end
        end
        
        local goldAmt = getQuantity("Gold")
        if goldAmt > 0 then
            local batch = math.min(goldAmt, 25)
            for i = 1, batch do
                Packets.InteractStructure.send({ entityID = entityID, itemID = ItemIDS.Gold })
            end
        end
        RunService.Heartbeat:Wait()
    end
end

local function campfireRefuel()
    while S.campfireFuel do
        if Cache.Deployables and Root then
            local rootPos = Root.Position
            for _, structure in ipairs(Cache.Deployables:GetChildren()) do
                if structure.Name == "Campfire" and (structure:GetPivot().Position - rootPos).Magnitude <= 40 then
                    local entityID = structure:GetAttribute("EntityID")
                    local textLabel = structure:FindFirstChild("Board", true) and 
                                    structure.Board:FindFirstChild("Billboard", true) and 
                                    structure.Board.Billboard:FindFirstChild("Backdrop", true) and 
                                    structure.Board.Billboard.Backdrop:FindFirstChild("TextLabel")
                    
                    if entityID and textLabel then
                        local fireValue = tonumber(textLabel.Text) or 999
                        if fireValue <= 200 then
                            for i = 1, math.min(10, math.floor((250 - fireValue) / 50)) do
                                Packets.InteractStructure.send({ entityID = entityID, itemID = ItemIDS.Coal })
                            end
                        end
                    end
                end
            end
        end
        task.wait(0.25)
    end
end

local function tpRawGold()
    local chestPos = nil
    while S.tpRawGoldToChest do
        if not S.chest or not S.chest.Parent then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then task.wait(0.5) continue end
            chestPos = S.chest:GetPivot()
        end
        
        local inventory = GameUtil.getData().inventory
        for idx, data in pairs(inventory) do
            if data.name == "Raw Gold" and data.quantity > 0 then
                local dropAmount = math.min(data.quantity, 50)
                for i = 1, dropAmount do
                    Packets.DropBagItem.send(idx, 1)
                end
                
                task.wait(0.05)
                
                if Cache.Items then
                    for _, item in ipairs(Cache.Items:GetChildren()) do
                        if item.Name == "Raw Gold" then
                            local id = item:GetAttribute("EntityID")
                            if id then
                                Packets.ForceInteract.send(id)
                                pcall(item.PivotTo, item, chestPos * CFrame.new(0, 2, 0))
                                Packets.ForceInteract.send()
                            end
                        end
                    end
                end
                break
            end
        end
        RunService.Heartbeat:Wait()
    end
end

local function pickupGoldFromChest()
    while S.pickupGoldFromChest do
        if not S.chest or not S.chest.Parent then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then task.wait(1) continue end
        end
        
        local contents = S.chest:FindFirstChild("Contents")
        if contents then
            for _, item in ipairs(contents:GetChildren()) do
                if item.Name == "Gold" then
                    local id = item:GetAttribute("EntityID")
                    if id then
                        for i = 1, 5 do Packets.Pickup.send(id) end
                    end
                end
            end
        end
        RunService.Heartbeat:Wait()
    end
end

local blackScreenGui = nil
local originalLighting = {}

local function enableBlackScreen()
    if not blackScreenGui then
        blackScreenGui = Instance.new("ScreenGui")
        blackScreenGui.Name = "BlackScreenOptimizer"
        blackScreenGui.IgnoreGuiInset = true
        blackScreenGui.ResetOnSpawn = false
        
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundColor3 = Color3.new(0, 0, 0)
        frame.BorderSizePixel = 0
        frame.Parent = blackScreenGui
        
        blackScreenGui.Parent = Player:WaitForChild("PlayerGui")
    end
    
    originalLighting = {
        Brightness = Lighting.Brightness,
        GlobalShadows = Lighting.GlobalShadows,
        OutdoorAmbient = Lighting.OutdoorAmbient,
        Ambient = Lighting.Ambient,
    }
    
    Lighting.Brightness = 0
    Lighting.GlobalShadows = false
    Lighting.OutdoorAmbient = Color3.new(0, 0, 0)
    Lighting.Ambient = Color3.new(0, 0, 0)
    
    for _, effect in pairs(Lighting:GetChildren()) do
        if effect:IsA("PostEffect") then effect.Enabled = false end
    end
end

local function disableBlackScreen()
    if blackScreenGui then
        blackScreenGui:Destroy()
        blackScreenGui = nil
    end
    
    if originalLighting.Brightness then
        Lighting.Brightness = originalLighting.Brightness
        Lighting.GlobalShadows = originalLighting.GlobalShadows
        Lighting.OutdoorAmbient = originalLighting.OutdoorAmbient
        Lighting.Ambient = originalLighting.Ambient
    end
    
    for _, effect in pairs(Lighting:GetChildren()) do
        if effect:IsA("PostEffect") then effect.Enabled = true end
    end
end

local tween = nil
local tweenConn = nil

local function startTweening()
    if #S.positions == 0 then
        Library:Notify('No positions available')
        return
    end

    local function nearestIndex(fromPos)
        local bestI, bestD = 1, math.huge
        for j = 1, #S.positions do
            local p = S.positions[j]
            if p and p.X and p.Y and p.Z then
                local d = (fromPos - Vector3.new(p.X, p.Y, p.Z)).Magnitude
                if d < bestD then bestI, bestD = j, d end
            end
        end
        return bestI
    end

    local curIndex = nearestIndex(Root.Position)
    local rbCount = {}
    local stuckTime = 0
    local lastCheckPos = Root.Position

    while S.tween and S.isMoving do
        if curIndex < 1 or curIndex > #S.positions then curIndex = 1 end

        local pos = S.positions[curIndex]
        if not (pos and pos.X and pos.Y and pos.Z) then
            curIndex = (curIndex % #S.positions) + 1
            task.wait(0.05)
            continue
        end

        local targetPos = Vector3.new(pos.X, pos.Y, pos.Z)
        local startPos = Root.Position
        local dist = (startPos - targetPos).Magnitude
        local duration = math.max(0.02, dist / S.tweenSpeed)

        if tweenConn then tweenConn:Disconnect() tweenConn = nil end
        if tween then tween:Cancel() tween = nil end
        
        tween = TweenService:Create(Root, TweenInfo.new(duration, Enum.EasingStyle.Linear), {CFrame = CFrame.new(targetPos)})

        local completed = false
        local rubberbanded = false
        local stuck = false

        local t0 = tick()
        local lastPos = startPos
        local lastDist = dist
        local lastMoveCheck = t0

        tweenConn = tween.Completed:Connect(function()
            completed = true
            if tweenConn then tweenConn:Disconnect() tweenConn = nil end
        end)

        tween:Play()

        task.spawn(function()
            while S.tween and S.isMoving and not completed do
                task.wait(0.3)

                local now = tick()
                local elapsed = now - t0
                local alpha = math.clamp(elapsed / duration, 0, 1)

                local curPos = Root.Position
                local curDist = (curPos - targetPos).Magnitude

                if curDist <= 5 then
                    completed = true
                    break
                end

                if (now - lastMoveCheck) >= 1.5 then
                    local moveDist = (curPos - lastCheckPos).Magnitude
                    if moveDist < 2 then
                        stuckTime = stuckTime + 1.5
                        if stuckTime >= 3 then
                            stuck = true
                            break
                        end
                    else
                        stuckTime = 0
                    end
                    lastCheckPos = curPos
                    lastMoveCheck = now
                end

                local stepJump = (curPos - lastPos).Magnitude
                if (curDist - lastDist) >= 12 then
                    rubberbanded = true
                    break
                end

                if stepJump >= 20 and elapsed > 0.5 then
                    rubberbanded = true
                    break
                end

                local expectPos = startPos:Lerp(targetPos, alpha)
                local dev = (curPos - expectPos).Magnitude
                if dev >= 10 and elapsed > 1 then
                    local vmag = Root.AssemblyLinearVelocity.Magnitude
                    if vmag < 0.5 then
                        rubberbanded = true
                        break
                    end
                end

                lastDist = curDist
                lastPos = curPos
            end

            if rubberbanded or stuck then
                if tweenConn then tweenConn:Disconnect() tweenConn = nil end
                if tween then tween:Cancel() tween = nil end

                task.wait(0.5)
                
                local serverPos = Root.Position
                local newIndex = nearestIndex(serverPos)

                rbCount[curIndex] = (rbCount[curIndex] or 0) + 1
                if rbCount[curIndex] >= 2 then
                    rbCount[curIndex] = 0
                    curIndex = (curIndex % #S.positions) + 1
                else
                    curIndex = newIndex
                end
                
                stuckTime = 0
                lastCheckPos = serverPos
            end
        end)

        while not completed and S.tween and S.isMoving do
            task.wait()
        end

        if tweenConn then tweenConn:Disconnect() tweenConn = nil end
        if tween then tween:Cancel() tween = nil end

        if not rubberbanded and not stuck then
            rbCount[curIndex] = 0
            stuckTime = 0
            curIndex = (curIndex % #S.positions) + 1
        end
        
        task.wait(S.waitTime)
    end
end

repeat task.wait(0.1) until Library

local Window = Library:CreateWindow({
    Title = 'Gold Farm Hub',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Main'),
    Extras = Window:AddTab('Extras'),
    Performance = Window:AddTab('Performance'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local MainBox = Tabs.Main:AddLeftGroupbox('Main')

MainBox:AddButton('Anti-AFK', function()
    setupAntiAFK()
    Library:Notify('Anti-AFK enabled!')
end)

MainBox:AddToggle('AutoHit', {
    Text = 'Auto Hit',
    Default = false,
    Callback = function(v)
        S.autoHit = v
        if v then
            Connections.autoHit = RunService.Heartbeat:Connect(hitResources)
        else
            if Connections.autoHit then Connections.autoHit:Disconnect() end
        end
    end
})

MainBox:AddToggle('Noclip', {
    Text = 'Noclip',
    Default = false,
    Callback = function(v)
        S.noclip = v
        noclip()
        if v then
            Connections.noclip = RunService.Heartbeat:Connect(noclip)
        else
            if Connections.noclip then Connections.noclip:Disconnect() end
            noclip()
        end
    end
})

MainBox:AddDropdown('FruitSelect', {
    Values = fruitOptions,
    Default = 1,
    Multi = false,
    Text = 'Select Fruit',
    Callback = function(v) S.fruit = v end
})

MainBox:AddToggle('AutoEat', {
    Text = 'Auto Eat',
    Default = false,
    Callback = function(v)
        S.autoEat = v
        if v then Tasks.autoEat = task.spawn(autoEat)
        else if Tasks.autoEat then task.cancel(Tasks.autoEat) end end
    end
})

local TweenBox = Tabs.Main:AddRightGroupbox('Tweening')

TweenBox:AddToggle('Tween', {
    Text = 'Enable Tween',
    Default = false,
    Callback = function(v)
        S.tween = v
        S.isMoving = v
        if v then
            task.wait(0.5)
            if config.positions then
                S.positions = config.positions
            end
            Tasks.tween = task.spawn(startTweening)
        else
            if tween then tween:Cancel() tween = nil end
            if tweenConn then tweenConn:Disconnect() tweenConn = nil end
            if Tasks.tween then task.cancel(Tasks.tween) end
        end
    end
})

TweenBox:AddSlider('Speed', {
    Text = 'Tween Speed',
    Default = 20,
    Min = 5,
    Max = 50,
    Rounding = 1,
    Compact = false,
    Callback = function(v)
        S.tweenSpeed = v
    end
})

TweenBox:AddSlider('WaitTime', {
    Text = 'Wait Time (s)',
    Default = 0.01,
    Min = 0,
    Max = 5,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        S.waitTime = v
    end
})

TweenBox:AddLabel('Anti-Rubberband: ENABLED')
TweenBox:AddLabel('Positions: Loading...')

task.spawn(function()
    task.wait(1)
    if config.positions then
        S.positions = config.positions
        TweenBox:AddLabel('Positions: ' .. #S.positions)
    end
end)

local PickupBox = Tabs.Main:AddLeftGroupbox('Instant Pickup')

PickupBox:AddToggle('PickupGold', {
    Text = 'Pickup Raw Gold',
    Default = false,
    Callback = function(v)
        S.pickupGold = v
        if v then Tasks.pickupGold = task.spawn(pickupGolds)
        else if Tasks.pickupGold then task.cancel(Tasks.pickupGold) end end
    end
})

PickupBox:AddToggle('PickupCoal', {
    Text = 'Pickup Coal',
    Default = false,
    Callback = function(v)
        S.pickupCoal = v
        if v then Tasks.pickupCoal = task.spawn(pickupCoals)
        else if Tasks.pickupCoal then task.cancel(Tasks.pickupCoal) end end
    end
})

PickupBox:AddToggle('PickupCoins', {
    Text = 'Pickup Coins',
    Default = false,
    Callback = function(v)
        S.pickupCoins = v
        if v then Tasks.pickupCoins = task.spawn(pickupCoins)
        else if Tasks.pickupCoins then task.cancel(Tasks.pickupCoins) end end
    end
})

local ExtrasBox = Tabs.Extras:AddLeftGroupbox('Extras')

ExtrasBox:AddToggle('CoinPress', {
    Text = 'Auto Coin Press',
    Default = false,
    Callback = function(v)
        S.coinPress = v
        if v then Tasks.coinPress = task.spawn(pressCoins)
        else if Tasks.coinPress then task.cancel(Tasks.coinPress) end end
    end
})

ExtrasBox:AddToggle('CampfireFuel', {
    Text = 'Auto Fuel Campfire',
    Default = false,
    Callback = function(v)
        S.campfireFuel = v
        if v then Tasks.campfireFuel = task.spawn(campfireRefuel)
        else if Tasks.campfireFuel then task.cancel(Tasks.campfireFuel) end end
    end
})

ExtrasBox:AddToggle('TPGoldToChest', {
    Text = 'TP Gold to Chest',
    Default = false,
    Callback = function(v)
        S.tpRawGoldToChest = v
        if v then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then
                S.tpRawGoldToChest = false
                Library:Notify('No chest found!')
                return
            end
            Tasks.tpRawGold = task.spawn(tpRawGold)
        else
            if Tasks.tpRawGold then task.cancel(Tasks.tpRawGold) end
        end
    end
})

ExtrasBox:AddToggle('PickupGoldFromChest', {
    Text = 'Pickup Gold from Chest',
    Default = false,
    Callback = function(v)
        S.pickupGoldFromChest = v
        if v then
            S.chest = getDeployable("Chest", 100)
            if not S.chest then
                S.pickupGoldFromChest = false
                Library:Notify('No chest found!')
                return
            end
            Tasks.pickupGoldFromChest = task.spawn(pickupGoldFromChest)
        else
            if Tasks.pickupGoldFromChest then task.cancel(Tasks.pickupGoldFromChest) end
        end
    end
})

local PerfBox = Tabs.Performance:AddLeftGroupbox('Performance Boost')

PerfBox:AddLabel('Black Screen Mode')

PerfBox:AddToggle('BlackScreen', {
    Text = 'Enable Black Screen',
    Default = false,
    Tooltip = 'Covers screen with black overlay',
    Callback = function(v)
        S.blackScreen = v
        if v then
            enableBlackScreen()
            Library:Notify('Black Screen Enabled!')
        else
            disableBlackScreen()
            Library:Notify('Black Screen Disabled')
        end
    end
})

PerfBox:AddDivider()
PerfBox:AddLabel('Benefits:')
PerfBox:AddLabel('• Massive FPS increase')
PerfBox:AddLabel('• Reduced GPU usage')
PerfBox:AddLabel('• Lower CPU overhead')

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
ThemeManager:SetFolder('GoldFarmHub')
SaveManager:SetFolder('GoldFarmHub/configs')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])

Library:OnUnload(function()
    Library.Unloaded = true
    if S.blackScreen then
        disableBlackScreen()
    end
    if tween then
        tween:Cancel()
    end
    if tweenConn then
        tweenConn:Disconnect()
    end
end)

Library:Notify('Gold Farm Hub loaded!')

task.spawn(function()
    task.wait(2)
    if config.positions then
        S.positions = config.positions
    end
end)